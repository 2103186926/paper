ä½ å·²ç»æœ‰ **0.1Â° Ã— 0.1Â° ç½‘æ ¼æ•°æ®**ï¼Œæƒ³é€šè¿‡ **æ’å€¼** åŠ å¯†åˆ° **0.01Â° Ã— 0.01Â°**ï¼Œè¿™åœ¨åœ°ç†ç©ºé—´æ•°æ®å¤„ç†ä¸­éå¸¸å¸¸è§ï¼Python æä¾›äº†å¼ºå¤§çš„å·¥å…·é“¾ï¼ˆ`scipy`ã€`xarray`ã€`pyresample` ç­‰ï¼‰æ¥å®ç°è¿™ä¸€ç›®æ ‡ã€‚ä¸‹é¢ï¼Œæˆ‘ä¼šè¯¦ç»†ä»‹ç» **ä¸‰ç§ä¸»æµæ’å€¼æ–¹æ³•**ï¼Œå¹¶ç»™å‡ºå®Œæ•´çš„ä»£ç ç¤ºä¾‹ã€‚

**æ–¹æ³•æ¦‚è¿°**
---------------

å‡è®¾ä½ çš„ **0.1Â° ç½‘æ ¼æ•°æ®** å½¢å¦‚ï¼š

| lon  | lat  | value |
| ---- | ---- | ----- |
| 73.0 | 20.0 | 10.2  |
| 73.1 | 20.0 | 10.5  |
| ...  | ...  | ...   |

ç›®æ ‡æ˜¯æ’å€¼åˆ° **0.01Â° ç½‘æ ¼**ï¼ˆå¦‚ `73.00, 73.01, 73.02, ..., 73.09, 73.10`ï¼‰ï¼Œ`value` ä¹Ÿå¯¹åº”åŠ å¯†ã€‚

**æ–¹æ³• 1ï¼šåŒçº¿æ€§æ’å€¼ï¼ˆBilinear Interpolationï¼‰**
--------------------------------------------------

æœ€å¸¸ç”¨ã€æœ€å¹³è¡¡çš„æ–¹æ³•ï¼Œé€‚åˆ**è¿ç»­æ¸å˜**çš„å˜é‡ï¼ˆæ¯”å¦‚æ¸©åº¦ã€æµ·æ‹”ã€é™æ°´ï¼‰ã€‚

```python
import numpy as np
import pandas as pd
from scipy.interpolate import griddata
import matplotlib.pyplot as plt

# 1. åŠ è½½0.1Â°ç½‘æ ¼æ•°æ®
df_coarse = pd.read_csv("china_grid_0.1_degree.csv")
# å‡è®¾åˆ—åä¸º: lon, lat, value (å¯ä»¥æ˜¯æ¸©åº¦ã€é«˜åº¦ã€é£é€Ÿç­‰ä»»æ„å­—æ®µ)

# 2. æå–ç²—ç½‘æ ¼çš„ç»çº¬åº¦å’Œå€¼
lon_coarse = df_coarse['lon'].values
lat_coarse = df_coarse['lat'].values
value_coarse = df_coarse['value'].values

# 3. å®šä¹‰ç›®æ ‡ç½‘æ ¼ï¼ˆ0.01Â°ï¼‰
lon_fine = np.arange(73, 135, 0.01)  # ç›®æ ‡ç»åº¦èŒƒå›´
lat_fine = np.arange(15, 55, 0.01)   # ç›®æ ‡çº¬åº¦èŒƒå›´
Lon_fine, Lat_fine = np.meshgrid(lon_fine, lat_fine)

# 4. åŒçº¿æ€§æ’å€¼
points = np.column_stack((lon_coarse, lat_coarse))  # (N, 2) ç²—ç½‘æ ¼ç‚¹åæ ‡
grid_values = griddata(
    points=points,        # ç²—ç½‘æ ¼ç»çº¬åº¦
    values=value_coarse,  # ç²—ç½‘æ ¼ä¸Šçš„å€¼
    xi=(Lon_fine, Lat_fine),  # ç›®æ ‡ç»†ç½‘æ ¼
    method='linear'       # åŒçº¿æ€§æ’å€¼
)

# grid_values.shape == (4000, 6200) â‰ˆ 2480ä¸‡ç‚¹ (0.01Â°ä¸­å›½åŒºåŸŸ)

# 5. è½¬ä¸ºDataFrameå¹¶ä¿å­˜
df_fine = pd.DataFrame({
    'lon': Lon_fine.flatten(),
    'lat': Lat_fine.flatten(),
    'value': grid_values.flatten()
})
df_fine = df_fine.dropna()  # å»é™¤æµ·å²¸çº¿å¤–æ’å€¼ä¸ºNaNçš„ç‚¹
df_fine.to_csv("china_grid_0.01_degree_bilinear.csv", index=False)

# 6. å¯è§†åŒ–æ£€æŸ¥
plt.figure(figsize=(10, 6))
plt.scatter(df_coarse['lon'], df_coarse['lat'], c=df_coarse['value'], s=10, label="0.1Â° Grid")
plt.contourf(Lon_fine, Lat_fine, grid_values, levels=50, cmap='viridis', alpha=0.6)
plt.colorbar(label="Value")
plt.title("Bilinear Interpolation (0.01Â°)")
plt.show()
```

**æ–¹æ³• 2ï¼šä¸‰æ¬¡æ ·æ¡æ’å€¼ï¼ˆCubic Splineï¼‰**
---------------------------------------------

æ¯”åŒçº¿æ€§æ›´å¹³æ»‘ï¼Œä½†**è®¡ç®—é‡æ›´å¤§**ï¼Œé€‚åˆ**é«˜é˜¶è¿ç»­**åœºæ™¯ï¼ˆå¦‚åœ°å½¢é«˜åº¦åœºï¼‰ã€‚

åªéœ€ä¿®æ”¹ä¸€è¡Œï¼š
```python
grid_values = griddata(points, value_coarse, (Lon_fine, Lat_fine), method='cubic')
```
**æ³¨æ„**ï¼š

- `cubic` å¯¹å™ªå£°æ•æ„Ÿï¼Œè‹¥ç²—ç½‘æ ¼æ•°æ®æ³¢åŠ¨å¤§ï¼Œå¯èƒ½å‡ºç°**è¿‡å†²**ï¼ˆovershootï¼‰ã€‚
- è¾¹ç¼˜æ˜“äº§ç”Ÿ `NaN`ï¼Œè®°å¾— `df_fine.dropna()`ã€‚

**æ–¹æ³• 3ï¼šæœ€è¿‘é‚»æ’å€¼ï¼ˆNearest Neighborï¼‰**
---------------------------------------------

**ä¸è¿›è¡Œå¹³æ»‘**ï¼Œç›´æ¥æŠŠæœ€è¿‘çš„0.1Â°æ ¼ç‚¹å€¼èµ‹ç»™0.01Â°ç½‘æ ¼ã€‚é€‚åˆ**ç¦»æ•£åˆ†ç±»æ•°æ®**ï¼ˆå¦‚åœŸåœ°åˆ©ç”¨ç±»å‹ã€è¡Œæ”¿åŒºç¼–ç ï¼‰ã€‚

```python
grid_values = griddata(points, value_coarse, (Lon_fine, Lat_fine), method='nearest')
```
æ•ˆæœç±»ä¼¼**æ”¾å¤§åƒç´ **ï¼Œæ— å¹³æ»‘è¿‡æ¸¡ã€‚

**è¿›é˜¶ï¼šåŸºäº `xarray` çš„é‡é‡‡æ ·ï¼ˆæ¨èï¼‰**
----------------------------------------------

`xarray` ç»“åˆ `scipy`ï¼Œä»£ç æ›´ç®€æ´ï¼Œæ”¯æŒ **NetCDFã€GRIB ç­‰æ …æ ¼æ•°æ®**ç›´æ¥æ’å€¼ã€‚

```python
import xarray as xr
import numpy as np

# 1. è¯»å–0.1Â°æ•°æ®ä¸ºxarrayæ ¼å¼ï¼ˆè‹¥åŸå§‹æ˜¯CSVï¼Œå…ˆè½¬NetCDFï¼‰
df_coarse = pd.read_csv("china_grid_0.1_degree.csv")
xr_coarse = xr.Dataset(
    data_vars={'value': (['lat', 'lon'], value_coarse.reshape(len(np.unique(lat_coarse)), len(np.unique(lon_coarse))))},
    coords={'lon': np.unique(lon_coarse), 'lat': np.unique(lat_coarse)}
)

# 2. å®šä¹‰ç»†ç½‘æ ¼
xr_fine = xr_coarse.interp(
    lon=np.arange(73, 135, 0.01),
    lat=np.arange(15, 55, 0.01),
    method='linear'  # å¯é€‰: linear, cubic, nearest
)

# 3. è½¬ä¸ºDataFrame
df_fine = xr_fine.to_dataframe().reset_index()
df_fine = df_fine.dropna()  # å»æµ·å²¸çº¿å¤–NaN
df_fine.to_csv("china_grid_0.01_degree_xarray.csv", index=False)
```

**æµ·å²¸çº¿æ©è†œä¼˜åŒ–ï¼ˆå…³é”®ï¼ï¼‰**
---------------------------

æ’å€¼åï¼Œ**æµ·å²¸çº¿å¤–**çš„çŸ©å½¢ç½‘æ ¼ä¼šæœ‰å¤§é‡ `NaN`ã€‚ç”¨ä¸Šä¸€èŠ‚çš„ **ä¸­å›½æµ·å²¸çº¿çŸ¢é‡æ•°æ®** å†è£å‰ªä¸€æ¬¡ï¼š

```python
import geopandas as gpd

# 1. åŠ è½½æµ·å²¸çº¿shp
china_border = gpd.read_file("china_coastline.shp").to_crs(epsg=4326)

# 2. è½¬ç»†ç½‘æ ¼ä¸ºGeoDataFrame
gdf_fine = gpd.GeoDataFrame(
    df_fine, geometry=gpd.points_from_xy(df_fine.lon, df_fine.lat), crs="EPSG:4326"
)

# 3. ç©ºé—´æŸ¥è¯¢ï¼šä»…ä¿ç•™è¾¹ç•Œå†…çš„ç‚¹
gdf_fine['in_china'] = gdf_fine.geometry.within(china_border.geometry.unary_union)
df_fine_filtered = gdf_fine[gdf_fine['in_china']][['lon', 'lat', 'value']]

# ä¿å­˜æœ€ç»ˆç»“æœ
df_fine_filtered.to_csv("china_coastal_grid_0.01_degree_final.csv", index=False)
```

**ä¸‰ç§æ’å€¼æ–¹æ³•æ¯”è¾ƒ**
----------------------

| æ–¹æ³•         | é€‚ç”¨åœºæ™¯                       | å¹³æ»‘åº¦ | è®¡ç®—é€Ÿåº¦ |
| ------------ | ------------------------------ | ------ | -------- |
| **åŒçº¿æ€§**   | è¿ç»­åœºï¼ˆæ°”æ¸©ã€é™æ°´ã€æµ·æ‹”ï¼‰     | ä¸­ç­‰   | å¿«       |
| **ä¸‰æ¬¡æ ·æ¡** | é«˜ç²¾åº¦åœ°å½¢ã€å¹³æ»‘åº¦è¦æ±‚é«˜       | é«˜     | æ…¢       |
| **æœ€è¿‘é‚»**   | ç¦»æ•£åˆ†ç±»ï¼ˆåœŸåœ°ç±»å‹ã€è¡Œæ”¿åŒºåˆ’ï¼‰ | æ—      | æœ€å¿«     |

**æ•°æ®é‡é¢„ä¼°**
- 0.1Â°ç½‘æ ¼ï¼ˆä¸­å›½ï¼‰ï¼šçº¦ 6.2ä¸‡ ç‚¹
- 0.01Â°ç½‘æ ¼ï¼ˆä¸­å›½ï¼‰ï¼šçº¦ **620ä¸‡ ç‚¹**ï¼ˆ100å€ï¼‰
- æµ·å²¸çº¿5å…¬é‡Œç¼“å†²åï¼šçº¦ **50ä¸‡~100ä¸‡ æœ‰æ•ˆç‚¹**

**è€—æ—¶å‚è€ƒ**
- åŒçº¿æ€§æ’å€¼ï¼š1~3åˆ†é’Ÿï¼ˆä¸æ•°æ®é‡å’Œæœºå™¨æ€§èƒ½ç›¸å…³ï¼‰
- ä¸‰æ¬¡æ ·æ¡æ’å€¼ï¼š5~10åˆ†é’Ÿ
- `xarray`é‡é‡‡æ ·ï¼š2~5åˆ†é’Ÿ

**æœ€åæ£€æŸ¥**
1. ç”¨ `matplotlib` æˆ– `cartopy` ç”»å›¾ï¼Œæ¯”å¯¹ **0.1Â° â†’ 0.01Â°** æ’å€¼å‰ååˆ†å¸ƒã€‚
2. è®¡ç®—æ’å€¼å‰å **å‡å€¼ã€æ ‡å‡†å·®**ï¼Œç¡®ä¿**èƒ½é‡å®ˆæ’**ï¼ˆæ— ç³»ç»Ÿæ€§åå·®ï¼‰ã€‚

è‡³æ­¤ï¼Œä½ å·²æŒæ¡ **Python ç©ºé—´æ’å€¼åŠ å¯†ç½‘æ ¼** çš„æ ¸å¿ƒæŠ€å·§ï¼ ğŸ‰

**æ‰©å±•é˜…è¯»**
- è‹¥æ•°æ®æ˜¯ **å¤šæ—¶ç›¸**ï¼ˆå¦‚é€æ—¥æ°”è±¡æ•°æ®ï¼‰ï¼Œå¯ç”¨ `xarray` çš„ `resample` æˆ– `interp` å¤„ç†æ—¶é—´ç»´åº¦ã€‚
- éœ€è¦æ›´ç²¾ç¡®çš„æµ·å²¸çº¿æ•ˆæœï¼Ÿè¯•è¯• **Delaunayä¸‰è§’ç½‘æ’å€¼**ï¼ˆ`scipy.spatial.Delaunay`ï¼‰ã€‚
- æ•°æ®è¶…å¤§ï¼ˆ>1000ä¸‡ç‚¹ï¼‰ï¼Ÿä¸Š **`dask` å¹¶è¡Œè®¡ç®—**ï¼ŒåŠ é€Ÿ10å€ï¼

Happy Interpolating! ğŸŒŸ



è¦å°†ç²¾åº¦ä¸º0.1åº¦çš„ç½‘æ ¼æ•°æ®æ’å€¼åˆ°ç²¾åº¦ä¸º0.01åº¦çš„ç½‘æ ¼æ•°æ®ï¼Œå¯ä»¥ä½¿ç”¨Pythonä¸­çš„ç§‘å­¦è®¡ç®—å’Œåœ°ç†ä¿¡æ¯å¤„ç†åº“ï¼Œä¾‹å¦‚`scipy`ã€`numpy`å’Œ`geopandas`ã€‚æ’å€¼æ–¹æ³•çš„é€‰æ‹©å–å†³äºæ•°æ®çš„ç‰¹æ€§ï¼ˆä¾‹å¦‚æ˜¯å¦æ˜¯è¿ç»­æ•°æ®ã€æ˜¯å¦æœ‰ç©ºé—´ç›¸å…³æ€§ç­‰ï¼‰ã€‚å¸¸ç”¨çš„æ’å€¼æ–¹æ³•åŒ…æ‹¬çº¿æ€§æ’å€¼ã€æœ€è¿‘é‚»æ’å€¼ã€æ ·æ¡æ’å€¼ã€Krigingæ’å€¼ç­‰ã€‚

ä»¥ä¸‹æ˜¯ä¸€ä¸ªè¯¦ç»†çš„æ­¥éª¤å’Œç¤ºä¾‹ä»£ç ï¼Œå¸®åŠ©ä½ å®ç°ä»0.1åº¦ç²¾åº¦åˆ°0.01åº¦ç²¾åº¦çš„ç½‘æ ¼æ’å€¼ã€‚

---

### æ­¥éª¤æ¦‚è¿°
1. **åŠ è½½åŸå§‹ç½‘æ ¼æ•°æ®**ï¼šè¯»å–ç²¾åº¦ä¸º0.1åº¦çš„ç½‘æ ¼æ•°æ®ï¼ˆå‡è®¾æ•°æ®åŒ…å«ç»çº¬åº¦å’Œå±æ€§å€¼ï¼‰ã€‚
2. **ç”Ÿæˆç›®æ ‡ç½‘æ ¼**ï¼šåˆ›å»ºç²¾åº¦ä¸º0.01åº¦çš„ç›®æ ‡ç½‘æ ¼ï¼Œè¦†ç›–ç›¸åŒçš„åœ°ç†èŒƒå›´ã€‚
3. **é€‰æ‹©æ’å€¼æ–¹æ³•**ï¼šæ ¹æ®æ•°æ®ç‰¹æ€§é€‰æ‹©åˆé€‚çš„æ’å€¼æ–¹æ³•ï¼ˆä¾‹å¦‚çº¿æ€§æ’å€¼ã€æ ·æ¡æ’å€¼ç­‰ï¼‰ã€‚
4. **æ‰§è¡Œæ’å€¼**ï¼šå¯¹åŸå§‹æ•°æ®è¿›è¡Œæ’å€¼ï¼Œç”Ÿæˆé«˜ç²¾åº¦ç½‘æ ¼æ•°æ®ã€‚
5. **ä¿å­˜ç»“æœ**ï¼šå°†æ’å€¼ç»“æœä¿å­˜ä¸ºåœ°ç†æ•°æ®æ ¼å¼ï¼ˆå¦‚Shapefileæˆ–GeoJSONï¼‰ã€‚

---

### æ‰€éœ€åº“
åœ¨å¼€å§‹ä¹‹å‰ï¼Œç¡®ä¿å®‰è£…ä»¥ä¸‹Pythonåº“ï¼š
```bash
pip install numpy scipy geopandas matplotlib
```

---

### å…·ä½“å®ç°ä»£ç 

ä»¥ä¸‹æ˜¯ä¸€ä¸ªå®Œæ•´çš„Pythonä»£ç ç¤ºä¾‹ï¼Œå‡è®¾ä½ çš„åŸå§‹ç½‘æ ¼æ•°æ®æ˜¯ä¸€ä¸ªåŒ…å«ç»çº¬åº¦å’Œå±æ€§å€¼çš„è¡¨æ ¼ï¼ˆä¾‹å¦‚CSVæˆ–Shapefileæ ¼å¼ï¼‰ã€‚æˆ‘ä»¬å°†ä½¿ç”¨`scipy`çš„æ’å€¼åŠŸèƒ½æ¥å®ç°æ’å€¼ã€‚

```python
import numpy as np
import geopandas as gpd
from scipy.interpolate import griddata
from shapely.geometry import Polygon
import matplotlib.pyplot as plt

# 1. åŠ è½½åŸå§‹ç½‘æ ¼æ•°æ®ï¼ˆå‡è®¾æ˜¯CSVæˆ–Shapefileæ ¼å¼ï¼‰
# è¿™é‡Œå‡è®¾ä½ çš„æ•°æ®æ˜¯ä¸€ä¸ªCSVæ–‡ä»¶ï¼ŒåŒ…å«ç»çº¬åº¦å’Œå±æ€§å€¼
# å¦‚æœæ˜¯Shapefileï¼Œå¯ä»¥ç”¨geopandasè¯»å–
input_file = "path_to_your_grid_data.csv"  # è¯·æ›¿æ¢ä¸ºå®é™…è·¯å¾„
# ç¤ºä¾‹æ•°æ®æ ¼å¼ï¼šlon, lat, value
# ä¾‹å¦‚ï¼š114.0, 30.0, 10.5
data = np.loadtxt(input_file, delimiter=',', skiprows=1)  # å‡è®¾ç¬¬ä¸€è¡Œæ˜¯æ ‡é¢˜è¡Œ

# æå–ç»çº¬åº¦å’Œå±æ€§å€¼
lons = data[:, 0]  # ç»åº¦
lats = data[:, 1]  # çº¬åº¦
values = data[:, 2]  # å±æ€§å€¼

# 2. å®šä¹‰åŸå§‹ç½‘æ ¼èŒƒå›´
min_lon, max_lon = lons.min(), lons.max()
min_lat, max_lat = lats.min(), lats.max()

# 3. ç”Ÿæˆç›®æ ‡ç½‘æ ¼ï¼ˆç²¾åº¦ä¸º0.01åº¦ï¼‰
grid_resolution = 0.01
target_lons = np.arange(min_lon, max_lon + grid_resolution, grid_resolution)
target_lats = np.arange(min_lat, max_lat + grid_resolution, grid_resolution)
target_lon_grid, target_lat_grid = np.meshgrid(target_lons, target_lats)

# 4. æ‰§è¡Œæ’å€¼
# ä½¿ç”¨scipyçš„griddataå‡½æ•°ï¼Œæ”¯æŒå¤šç§æ’å€¼æ–¹æ³•ï¼ˆlinear, nearest, cubicç­‰ï¼‰
# é€‰æ‹©æ’å€¼æ–¹æ³•ï¼š'linear'ï¼ˆçº¿æ€§æ’å€¼ï¼‰ã€'nearest'ï¼ˆæœ€è¿‘é‚»æ’å€¼ï¼‰ã€'cubic'ï¼ˆä¸‰æ¬¡æ’å€¼ï¼‰
interp_method = 'linear'
interp_values = griddata(
    points=(lons, lats),  # åŸå§‹æ•°æ®ç‚¹çš„ç»çº¬åº¦
    values=values,        # åŸå§‹æ•°æ®ç‚¹çš„å±æ€§å€¼
    xi=(target_lon_grid, target_lat_grid),  # ç›®æ ‡ç½‘æ ¼çš„ç»çº¬åº¦
    method=interp_method  # æ’å€¼æ–¹æ³•
)

# 5. å°†æ’å€¼ç»“æœè½¬æ¢ä¸ºGeoDataFrameï¼ˆå¯é€‰ï¼‰
# å¦‚æœéœ€è¦ä¿å­˜ä¸ºåœ°ç†æ•°æ®æ ¼å¼ï¼ˆå¦‚Shapefileï¼‰ï¼Œéœ€è¦å°†ç½‘æ ¼è½¬æ¢ä¸ºå¤šè¾¹å½¢
grid_polygons = []
grid_values = []
for i in range(len(target_lats) - 1):
    for j in range(len(target_lons) - 1):
        # å®šä¹‰æ¯ä¸ªç½‘æ ¼å•å…ƒçš„å››è¾¹å½¢
        grid_poly = Polygon([
            (target_lons[j], target_lats[i]),
            (target_lons[j + 1], target_lats[i]),
            (target_lons[j + 1], target_lats[i + 1]),
            (target_lons[j], target_lats[i + 1])
        ])
        grid_polygons.append(grid_poly)
        # æå–å¯¹åº”ç½‘æ ¼å•å…ƒçš„æ’å€¼ç»“æœ
        grid_values.append(interp_values[i, j])

# åˆ›å»ºGeoDataFrame
grid_gdf = gpd.GeoDataFrame(
    {'value': grid_values},
    geometry=grid_polygons,
    crs='EPSG:4326'  # WGS84åæ ‡ç³»
)

# 6. å¯è§†åŒ–ç»“æœï¼ˆå¯é€‰ï¼‰
fig, ax = plt.subplots(figsize=(10, 10))
grid_gdf.plot(column='value', ax=ax, cmap='viridis', legend=True, alpha=0.5)
plt.title(f"Interpolated Grid (Resolution: {grid_resolution}Â°)")
plt.xlabel("Longitude")
plt.ylabel("Latitude")
plt.show()

# 7. ä¿å­˜ç»“æœä¸ºShapefile
output_file = "interpolated_grid_0.01.shp"  # è¾“å‡ºæ–‡ä»¶è·¯å¾„
grid_gdf.to_file(output_file)
print(f"Interpolated grid data saved to {output_file}")
```

---

### ä»£ç è¯´æ˜

1. **åŠ è½½åŸå§‹æ•°æ®**ï¼š
   - å‡è®¾ä½ çš„åŸå§‹æ•°æ®æ˜¯ä¸€ä¸ªCSVæ–‡ä»¶ï¼ŒåŒ…å«ç»çº¬åº¦å’Œå±æ€§å€¼ï¼ˆä¾‹å¦‚`lon, lat, value`ï¼‰ã€‚
   - å¦‚æœä½ çš„æ•°æ®æ˜¯Shapefileæ ¼å¼ï¼Œå¯ä»¥ä½¿ç”¨`geopandas`è¯»å–ï¼Œå¹¶æå–å‡ ä½•ä¸­å¿ƒç‚¹çš„ç»çº¬åº¦ä½œä¸ºæ’å€¼ç‚¹ã€‚

2. **ç”Ÿæˆç›®æ ‡ç½‘æ ¼**ï¼š
   - ä½¿ç”¨`numpy.arange`ç”Ÿæˆç²¾åº¦ä¸º0.01åº¦çš„ç›®æ ‡ç½‘æ ¼ã€‚
   - ä½¿ç”¨`numpy.meshgrid`ç”Ÿæˆç›®æ ‡ç½‘æ ¼çš„ç»çº¬åº¦åæ ‡çŸ©é˜µã€‚

3. **æ‰§è¡Œæ’å€¼**ï¼š
   - ä½¿ç”¨`scipy.interpolate.griddata`è¿›è¡Œæ’å€¼ï¼Œæ”¯æŒå¤šç§æ–¹æ³•ï¼š
     - `'nearest'`ï¼šæœ€è¿‘é‚»æ’å€¼ï¼Œé€‚åˆç¦»æ•£æˆ–åˆ†ç±»æ•°æ®ã€‚
     - `'linear'`ï¼šçº¿æ€§æ’å€¼ï¼Œé€‚åˆè¿ç»­æ•°æ®ï¼Œè®¡ç®—æ•ˆç‡è¾ƒé«˜ã€‚
     - `'cubic'`ï¼šä¸‰æ¬¡æ’å€¼ï¼Œé€‚åˆå¹³æ»‘çš„è¿ç»­æ•°æ®ï¼Œä½†è®¡ç®—æˆæœ¬è¾ƒé«˜ã€‚
   - æ ¹æ®ä½ çš„æ•°æ®ç‰¹æ€§é€‰æ‹©åˆé€‚çš„æ’å€¼æ–¹æ³•ã€‚å¦‚æœæ•°æ®å…·æœ‰ç©ºé—´ç›¸å…³æ€§ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨æ›´é«˜çº§çš„æ’å€¼æ–¹æ³•ï¼ˆå¦‚Krigingï¼Œè§ä¸‹æ–‡æ‰©å±•éƒ¨åˆ†ï¼‰ã€‚

4. **è½¬æ¢ä¸ºGeoDataFrame**ï¼š
   - å°†æ’å€¼ç»“æœè½¬æ¢ä¸ºåœ°ç†æ•°æ®æ ¼å¼ï¼ˆ`GeoDataFrame`ï¼‰ï¼Œä»¥ä¾¿ä¿å­˜ä¸ºShapefileæˆ–GeoJSONã€‚
   - æ¯ä¸ªç½‘æ ¼å•å…ƒè¢«è¡¨ç¤ºä¸ºä¸€ä¸ªå››è¾¹å½¢ï¼ˆ`Polygon`ï¼‰ï¼Œå¹¶é™„å¸¦æ’å€¼åçš„å±æ€§å€¼ã€‚

5. **å¯è§†åŒ–å’Œä¿å­˜**ï¼š
   - ä½¿ç”¨`matplotlib`ç»˜åˆ¶æ’å€¼ç»“æœçš„å¯è§†åŒ–å›¾ï¼Œä»¥ä¾¿ç›´è§‚æ£€æŸ¥æ’å€¼æ•ˆæœã€‚
   - å°†ç»“æœä¿å­˜ä¸ºShapefileï¼Œæ–¹ä¾¿åœ¨GISè½¯ä»¶ï¼ˆå¦‚QGISï¼‰ä¸­è¿›ä¸€æ­¥å¤„ç†ã€‚

---

### æ³¨æ„äº‹é¡¹

1. **æ’å€¼æ–¹æ³•é€‰æ‹©**ï¼š
   - å¦‚æœä½ çš„æ•°æ®æ˜¯è¿ç»­çš„ï¼ˆå¦‚æ¸©åº¦ã€é™é›¨é‡ç­‰ï¼‰ï¼Œæ¨èä½¿ç”¨`'linear'`æˆ–`'cubic'`æ’å€¼ã€‚
   - å¦‚æœä½ çš„æ•°æ®æ˜¯ç¦»æ•£çš„æˆ–åˆ†ç±»çš„ï¼ˆå¦‚åœŸåœ°ä½¿ç”¨ç±»å‹ï¼‰ï¼Œæ¨èä½¿ç”¨`'nearest'`æ’å€¼ã€‚
   - å¦‚æœä½ çš„æ•°æ®å…·æœ‰ç©ºé—´ç›¸å…³æ€§ï¼ˆä¾‹å¦‚åœ°ç†ç©ºé—´æ•°æ®ï¼‰ï¼Œå¯ä»¥è€ƒè™‘ä½¿ç”¨Krigingæ’å€¼ï¼ˆè§ä¸‹æ–‡æ‰©å±•éƒ¨åˆ†ï¼‰ã€‚

2. **æ•°æ®è¾¹ç•Œé—®é¢˜**ï¼š
   - æ’å€¼å¯èƒ½ä¼šåœ¨åŸå§‹æ•°æ®èŒƒå›´ä¹‹å¤–äº§ç”Ÿ`NaN`å€¼ï¼ˆä¾‹å¦‚è¾¹ç•ŒåŒºåŸŸï¼‰ã€‚ä½ å¯ä»¥ä½¿ç”¨`griddata`çš„`fill_value`å‚æ•°æŒ‡å®šå¡«å……å€¼ï¼Œæˆ–è€…åœ¨åç»­å¤„ç†ä¸­è¿‡æ»¤æ‰è¿™äº›åŒºåŸŸã€‚

3. **æ€§èƒ½ä¼˜åŒ–**ï¼š
   - å¦‚æœç›®æ ‡ç½‘æ ¼ç²¾åº¦å¾ˆé«˜ï¼ˆå¦‚0.01åº¦ï¼‰ï¼Œç½‘æ ¼æ•°é‡ä¼šéå¸¸å¤šï¼Œå¯èƒ½å¯¼è‡´è®¡ç®—æ•ˆç‡ä½ä¸‹ã€‚
   - å¯ä»¥è€ƒè™‘åˆ†å—å¤„ç†æˆ–ä½¿ç”¨å¹¶è¡Œè®¡ç®—ï¼ˆä¾‹å¦‚`dask`ï¼‰æ¥æé«˜æ•ˆç‡ã€‚

4. **æŠ•å½±é—®é¢˜**ï¼š
   - ä»£ç ä¸­ä½¿ç”¨çš„æ˜¯ç»çº¬åº¦åæ ‡ç³»ï¼ˆWGS84ï¼‰ã€‚å¦‚æœéœ€è¦æŠ•å½±åˆ°å…¶ä»–åæ ‡ç³»ï¼ˆå¦‚UTMï¼‰ï¼Œå¯ä»¥åœ¨ä¿å­˜ç»“æœå‰ä½¿ç”¨`geopandas`çš„`to_crs`æ–¹æ³•è¿›è¡ŒæŠ•å½±è½¬æ¢ã€‚

---

### æ‰©å±•åº”ç”¨

1. **ä½¿ç”¨Krigingæ’å€¼**ï¼š
   - å¦‚æœä½ çš„æ•°æ®å…·æœ‰ç©ºé—´ç›¸å…³æ€§ï¼Œå¯ä»¥ä½¿ç”¨Krigingæ’å€¼æ–¹æ³•ï¼Œè¿™æ˜¯ä¸€ç§åŸºäºç©ºé—´ç»Ÿè®¡çš„æ’å€¼æ–¹æ³•ï¼Œèƒ½å¤Ÿæ›´å¥½åœ°æ•æ‰ç©ºé—´å˜å¼‚æ€§ã€‚
   - Pythonä¸­å¯ä»¥ä½¿ç”¨`pykrige`åº“æ¥å®ç°Krigingæ’å€¼ã€‚å®‰è£…æ–¹æ³•ï¼š
     ```bash
     pip install pykrige
     ```
   - ç¤ºä¾‹ä»£ç ï¼š
     ```python
     from pykrige.ok import OrdinaryKriging
     
     # åˆ›å»ºKrigingæ¨¡å‹
     kriging_model = OrdinaryKriging(
         x=lons,  # åŸå§‹ç»åº¦
         y=lats,  # åŸå§‹çº¬åº¦
         z=values,  # åŸå§‹å±æ€§å€¼
         variogram_model='spherical'  # å˜å¼‚å‡½æ•°æ¨¡å‹
     )
     
     # åœ¨ç›®æ ‡ç½‘æ ¼ä¸Šæ‰§è¡ŒKrigingæ’å€¼
     interp_values, variance = kriging_model.execute(
         'grid', target_lons, target_lats
     )
     ```

2. **æ·»åŠ å±æ€§**ï¼š
   - å¯ä»¥ä¸ºæ¯ä¸ªç½‘æ ¼å•å…ƒæ·»åŠ é¢å¤–çš„å±æ€§ï¼Œä¾‹å¦‚ç½‘æ ¼ä¸­å¿ƒç‚¹çš„ç»çº¬åº¦ã€æ’å€¼è¯¯å·®ç­‰ã€‚

3. **å¹¶è¡Œè®¡ç®—**ï¼š
   - å¦‚æœç½‘æ ¼æ•°é‡è¿‡å¤šï¼Œå¯ä»¥ä½¿ç”¨`multiprocessing`æˆ–`dask`è¿›è¡Œå¹¶è¡Œè®¡ç®—



é™¤äº†ä½¿ç”¨scipyçš„griddataå‡½æ•°å¯ä»¥è¿›è¡Œæ’å€¼å¤–ï¼Œè¿˜æœ‰å…¶ä»–æ–¹æ³•æˆ–pythonå‡½æ•°è¿›è¡Œæ’å€¼æ¥æé«˜ç½‘æ ¼ç²¾åº¦å—

å½“ç„¶ï¼é™¤äº†`scipy.interpolate.griddata`ä¹‹å¤–ï¼ŒPython ä¸­è¿˜æœ‰å¾ˆå¤šå…¶ä»–æ–¹æ³•å’Œå‡½æ•°å¯ä»¥è¿›è¡Œæ’å€¼ï¼Œä»¥æé«˜ç½‘æ ¼æ•°æ®çš„ç²¾åº¦ã€‚ä¸åŒçš„æ’å€¼æ–¹æ³•é€‚ç”¨äºä¸åŒçš„åœºæ™¯å’Œæ•°æ®ç‰¹æ€§ã€‚ä¸‹é¢åˆ—ä¸¾äº†ä¸€äº›å¸¸è§çš„æ–¹æ³•å’Œå¯¹åº”çš„ Python å‡½æ•°æˆ–åº“ï¼š

**1. æœ€è¿‘é‚»æ’å€¼ (Nearest Neighbor Interpolation)**
- **æè¿°**ï¼šç®€å•åœ°å°†æŸ¥è¯¢ç‚¹çš„å€¼èµ‹ä¸ºæœ€è¿‘çš„æ•°æ®ç‚¹çš„å€¼ã€‚
- **å‡½æ•°**ï¼š
  - `scipy.interpolate.NearestNDInterpolator`ï¼ˆé€‚ç”¨äº N ç»´æ•°æ®ï¼‰
  - `scipy.interpolate.griddata(method='nearest')` ï¼ˆå·²æåŠï¼Œä½†ä¸ºäº†å®Œæ•´æ€§åˆ—å‡ºï¼‰
  - `sklearn.neighbors.NearestNeighbors` ï¼ˆæœºå™¨å­¦ä¹ åº“ä¸­çš„å®ç°ï¼Œç¨å¤æ‚ä½†æ›´çµæ´»ï¼‰

**ç¤ºä¾‹**ï¼š

```python
from scipy.interpolate import NearestNDInterpolator
import numpy as np

# å‡è®¾ points æ˜¯åŸå§‹æ•°æ®ç‚¹åæ ‡ï¼Œvalues æ˜¯å¯¹åº”çš„å€¼
points = np.random.rand(10, 2)  # 10ä¸ªéšæœº2Dç‚¹
values = np.random.rand(10)     # å¯¹åº”å€¼
interp = NearestNDInterpolator(points, values)
new_points = np.array([[0.5, 0.5]])  # å¾…æ’å€¼ç‚¹
result = interp(new_points)
```

**2. çº¿æ€§æ’å€¼ (Linear Interpolation)**
- **æè¿°**ï¼šåœ¨ç½‘æ ¼çš„æ¯ä¸ªä¸‰è§’å½¢ï¼ˆ2Dï¼‰æˆ–å››é¢ä½“ï¼ˆ3Dï¼‰å†…è¿›è¡Œçº¿æ€§æ’å€¼ã€‚
- **å‡½æ•°**ï¼š
  - `scipy.interpolate.LinearNDInterpolator` ï¼ˆN ç»´é€šç”¨ï¼‰
  - `scipy.interpolate.griddata(method='linear')` ï¼ˆå¯¹ grid æ•°æ®æœ‰æ•ˆï¼‰
  - `scipy.interpolate.interpn` ï¼ˆæ›´é€‚åˆç»“æ„åŒ–ç½‘æ ¼ï¼‰

**ç¤ºä¾‹**ï¼š
```python
from scipy.interpolate import LinearNDInterpolator

# åŸºäºä¸Šé¢çš„ points å’Œ values
interp = LinearNDInterpolator(points, values)
result = interp(new_points)
```

**3. ä¸‰æ¬¡æ’å€¼ (Cubic Interpolation)**
- **æè¿°**ï¼šä½¿ç”¨ä¸‰æ¬¡æ ·æ¡æ‹Ÿåˆæ•°æ®ï¼Œåœ¨å¹³æ»‘æ€§å’Œç²¾åº¦ä¸Šä¼˜äºçº¿æ€§æ’å€¼ï¼Œä½†è®¡ç®—é‡æ›´å¤§ã€‚
- **å‡½æ•°**ï¼š
  - `scipy.interpolate.CloughTocher2DInterpolator` ï¼ˆä»… 2Dï¼Œç²¾åº¦è¾ƒé«˜ï¼‰
  - `scipy.interpolate.griddata(method='cubic')` ï¼ˆä»… 2D/3Dï¼‰

**ç¤ºä¾‹**ï¼š
```python
from scipy.interpolate import CloughTocher2DInterpolator

interp = CloughTocher2DInterpolator(points, values)
result = interp(new_points)
```

**4. æ ·æ¡æ’å€¼ (Spline Interpolation)**
- **æè¿°**ï¼šåˆ†æ®µå¤šé¡¹å¼ï¼ˆé€šå¸¸æ˜¯ä¸‰æ¬¡ï¼‰æ’å€¼ï¼Œä¿æŒä¸€å®šç¨‹åº¦çš„å¹³æ»‘æ€§ï¼ˆè¿ç»­å¯¼æ•°ï¼‰ã€‚
- **å‡½æ•°**ï¼š
  - `scipy.interpolate.SmoothBivariateSpline` ï¼ˆ2D ç»“æ„åŒ–æ•°æ®ï¼‰
  - `scipy.interpolate.RectBivariateSpline` ï¼ˆ2D ç½‘æ ¼æ•°æ®ï¼‰
  - `scipy.interpolate.Rbf` ï¼ˆå¾„å‘åŸºå‡½æ•°æ’å€¼ï¼Œä¹Ÿæœ‰å¹³æ»‘æ•ˆæœï¼‰

**ç¤ºä¾‹**ï¼š
```python
from scipy.interpolate import SmoothBivariateSpline

# å‡è®¾ x, y æ˜¯ç»“æ„åŒ–çš„1Dåæ ‡ï¼Œz æ˜¯å¯¹åº”çš„2Då€¼çŸ©é˜µ
x = np.linspace(0, 1, 10)
y = np.linspace(0, 1, 10)
z = np.random.rand(10, 10)
interp = SmoothBivariateSpline(x, y, z)
result = interp(new_points[:,0], new_points[:,1])
```

**5. å¾„å‘åŸºå‡½æ•°æ’å€¼ (RBF, Radial Basis Function)**
- **æè¿°**ï¼šç”¨ä¸€ç³»åˆ—åŸºå‡½æ•°ï¼ˆå¦‚é«˜æ–¯ã€å¤šé¡¹å¼ç­‰ï¼‰æ‹Ÿåˆæ•°æ®ï¼Œå…¨å±€å…‰æ»‘ä½†è®¡ç®—å¤æ‚åº¦ $O(n^2)$ã€‚
- **å‡½æ•°**ï¼š
  - `scipy.interpolate.Rbf`

**ç¤ºä¾‹**ï¼š
```python
from scipy.interpolate import Rbf

rbf = Rbf(points[:,0], points[:,1], values, function='cubic')
result = rbf(new_points[:,0], new_points[:,1])
```

**6. å…‹é‡Œé‡‘æ’å€¼ (Kriging)**
- **æè¿°**ï¼šåŸºäºç»Ÿè®¡çš„æ’å€¼æ–¹æ³•ï¼Œè€ƒè™‘æ•°æ®çš„ç©ºé—´ç›¸å…³æ€§ï¼ˆåŠå˜å¼‚å‡½æ•°ï¼‰ã€‚é€‚ç”¨äºåœ°ç†æ•°æ®ã€‚
- **åº“**ï¼š
  - `PyKrige` ï¼ˆä¸“ç”¨åº“ï¼Œæ”¯æŒæ™®é€šå…‹é‡Œé‡‘ã€æ³›å…‹é‡Œé‡‘ç­‰ï¼‰
  - `scikit-gstat` ï¼ˆç»Ÿè®¡åœ°ç†åº“ï¼‰

**ç¤ºä¾‹ (PyKrige)**ï¼š
```bash
pip install pykrige
```
```python
from pykrige.ok import OrdinaryKriging

# å‡è®¾ x, y, z æ˜¯ 1D æ•°ç»„
OK = OrdinaryKriging(points[:,0], points[:,1], values, variogram_model='spherical')
z_interp, ss = OK.execute('grid', xgrid=np.linspace(0,1,50), ygrid=np.linspace(0,1,50))
```

**7. ç½‘æ ¼æ’å€¼ä¸“ç”¨å‡½æ•°**
- **ç»“æ„åŒ–ç½‘æ ¼**ï¼š
  - `scipy.interpolate.RegularGridInterpolator` ï¼ˆé«˜æ•ˆå¤„ç†å‡åŒ€ç½‘æ ¼ï¼‰
  - `scipy.interpolate.RectBivariateSpline` ï¼ˆ2D ç½‘æ ¼ï¼‰
  - `scipy.interpolate.interp2d` / `interp3d` ï¼ˆç®€å• 2D/3D ç½‘æ ¼ï¼‰

**ç¤ºä¾‹**ï¼š
```python
from scipy.interpolate import RegularGridInterpolator

x = np.linspace(0, 1, 10)
y = np.linspace(0, 1, 10)
X, Y = np.meshgrid(x, y, indexing='ij')
Z = np.random.rand(10, 10)
interp = RegularGridInterpolator((x, y), Z)
result = interp(new_points)
```

**æ–¹æ³•å¯¹æ¯”æ€»ç»“ï¼š**

| æ–¹æ³•                      | é€‚ç”¨ç»´åº¦ | å¹³æ»‘åº¦ | è®¡ç®—æ•ˆç‡ | å¤‡æ³¨                  |
| ------------------------- | -------- | ------ | -------- | --------------------- |
| æœ€è¿‘é‚» (`Nearest`)        | N-D      | å·®     | é«˜       | ç®€å•å¿«é€Ÿ              |
| çº¿æ€§ (`Linear`)           | N-D      | ä¸€èˆ¬   | ä¸­       | æœ€å¸¸ç”¨ï¼Œå¹³è¡¡ç²¾åº¦/æ•ˆç‡ |
| ä¸‰æ¬¡ (`Cubic`)            | 2D       | å¥½     | ä½       | æ•°æ®ç¨ å¯†æ—¶ç”¨          |
| æ ·æ¡ (`Spline`)           | 2D       | æå¥½   | ä¸­       | ç½‘æ ¼åŒ–æ•°æ®æœ€ä½³        |
| RBF                       | N-D      | æå¥½   | ä½       | å‚æ•°æ•æ„Ÿ              |
| å…‹é‡Œé‡‘ (`Kriging`)        | N-D      | å¥½     | ä¸­       | åœ°ç†/åœ°è´¨æ•°æ®ä¸“ç”¨     |
| `RegularGridInterpolator` | N-D      | å¥½     | æé«˜     | **ç»“æ„åŒ–ç½‘æ ¼ç¥å™¨**    |

**å®æˆ˜å»ºè®®**ï¼š
1. **ç¨€ç–æ•£ç‚¹æ•°æ®**ï¼šä¼˜å…ˆ `LinearNDInterpolator` æˆ– `Rbf`ã€‚
2. **ç»“æ„åŒ–ç½‘æ ¼æ•°æ®**ï¼šç”¨ `RegularGridInterpolator` æˆ– `RectBivariateSpline`ã€‚
3. **éœ€è¦æè‡´å¹³æ»‘**ï¼š`CloughTocher2DInterpolator` (2Dä¸‰æ¬¡æ’å€¼)ã€‚
4. **åœ°ç†ç»Ÿè®¡æ•°æ®**ï¼š`PyKrige` (å…‹é‡Œé‡‘æ–¹æ³•)ã€‚
5. **å¿«é€Ÿè¿‘ä¼¼**ï¼š`NearestNDInterpolator`ã€‚

è®°ä½ï¼Œæ²¡æœ‰ä¸‡èƒ½æ–¹æ³•ï¼Œéœ€æ ¹æ®ï¼š
- æ•°æ®ç‚¹æ˜¯å¦**ç»“æ„åŒ–**ï¼ˆç½‘æ ¼åŒ–ï¼‰ï¼Ÿ
- ç»´åº¦ï¼ˆ2D/3D/N-Dï¼‰ï¼Ÿ
- å¯¹**ç²¾åº¦**å’Œ**å¹³æ»‘åº¦**çš„è¦æ±‚ï¼Ÿ
- è®¡ç®—èµ„æºæ˜¯å¦å……è¶³ï¼Ÿ

æ¥é€‰æ‹©æœ€åˆé€‚çš„æ’å€¼æ–¹æ¡ˆï¼

ç¥ä½ æ’å€¼é¡ºåˆ©ï¼